/*
 * generated by Xtext
 */
package org.mutator.scoping

import java.io.File
import java.util.ArrayList
import java.util.List
import manager.ModelManager
import mutatorenvironment.CompleteTypeSelection
import mutatorenvironment.CompositeMutator
import mutatorenvironment.CreateObjectMutator
import mutatorenvironment.CreateReferenceMutator
import mutatorenvironment.Definition
import mutatorenvironment.Evaluation
import mutatorenvironment.Expression
import mutatorenvironment.ModifyInformationMutator
import mutatorenvironment.ModifySourceReferenceMutator
import mutatorenvironment.ModifyTargetReferenceMutator
import mutatorenvironment.Mutator
import mutatorenvironment.MutatorEnvironment
import mutatorenvironment.ObjectEmitter
import mutatorenvironment.OtherTypeSelection
import mutatorenvironment.Program
import mutatorenvironment.RandomTypeSelection
import mutatorenvironment.ReferenceEvaluation
import mutatorenvironment.ReferenceInit
import mutatorenvironment.RemoveCompleteReferenceMutator
import mutatorenvironment.RemoveObjectMutator
import mutatorenvironment.RemoveRandomReferenceMutator
import mutatorenvironment.RemoveSpecificReferenceMutator
import mutatorenvironment.SelectObjectMutator
import mutatorenvironment.SpecificObjectSelection
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EClassifier
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import mutatorenvironment.ReferenceSwap
import mutatorenvironment.ReferenceSet
import mutatorenvironment.ObSelectionStrategy
import mutatorenvironment.Block
import mutatorenvironment.Constraint

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class MutatorScopeProvider extends AbstractDeclarativeScopeProvider {
	
	/**
	 * CreateObjetMutator.type can contain any EClass from the input meta-model.
	 */
	def IScope scope_ObjectEmitter_type(ObjectEmitter obj, EReference ref) {
		System.out.println("1.")
		val MutatorEnvironment env = getMutatorEnvironment(obj)
        val Definition  definition = env.definition
       	// add metamodel classes to scope
       	Scopes.scopeFor( getEClasses(definition.metamodel) )   
	}				
	
	/**
	 * CreateObjectMutator.container, when a specific object is used as a container,
	 * can contain any previous object whose type is a container for the created object. 
	 */
	def IScope scope_SpecificObjectSelection_objSel(CreateObjectMutator com, EReference ref) {				
		System.out.println("2.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
        val List<Mutator> commands = getCommands(com)
        val Definition definition  = env.definition
        
        val List<EClass> containers  = getEContainers(definition.metamodel, com.type.name)
        val List<String> scontainers = new ArrayList<String>()
        for (EClassifier cl : containers) scontainers.add(cl.name)
        val List<EReference> references = getEReferences(definition.metamodel, com.type.name)
        for (EReference eref : references) {
        	scontainers.add(eref.getEType().name)
        }
        // example: create Class in c [where c is the result of a previous mutator]
        
        // find previously created objects, i.e., 
        // -mutations with a name, 
        // -previous to this one,
        // -where the created object has an appropriate type
        val scope = new ArrayList()
        for (mutator : commands) { 
        	if (mutator.name!=null && 
        		commands.indexOf(mutator) < commands.indexOf(com) &&
        		(mutator instanceof CreateObjectMutator || mutator instanceof ModifyInformationMutator || mutator instanceof SelectObjectMutator) &&
        		scontainers.contains(mutator.type.name))
			scope.add(mutator)
		}
        
        // add objects to scope
        Scopes.scopeFor(scope)
	}
	
	/**
	 * SelectObjectMutator.container, when a specific object is used as a container,
	 * can contain any previous object whose type is a container for the created object. 
	 */
	def IScope scope_SpecificObjectSelection_objSel(SelectObjectMutator com, EReference ref) {				
		System.out.println("2b.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
        val List<Mutator> commands = getCommands(com)
        val Definition definition  = env.definition
        
        val List<EClass> containers  = getEContainers(definition.metamodel, com.type.name)
        val List<String> scontainers = new ArrayList<String>()
        for (EClassifier cl : containers) scontainers.add(cl.name)

        // example: create Class in c [where c is the result of a previous mutator]
        
        // find previously created objects, i.e., 
        // -mutations with a name, 
        // -previous to this one,
        // -where the created object has an appropriate type
        val scope = new ArrayList()
        for (mutator : commands) {
        	if (mutator.name != null && 
        		commands.indexOf(mutator) < commands.indexOf(com) &&
        		mutator instanceof SelectObjectMutator && scontainers.contains(mutator.type.name)) 
				scope.add(mutator)
		}
        
        // add objects to scope
        Scopes.scopeFor(scope)
	}
	
	/**
	 * CompleteTypeSelection.type can contain any EClass from the input meta-model.
	 */
	def IScope scope_CompleteTypeSelection_type(CompleteTypeSelection com, EReference ref) {
		System.out.println("3.")
		anyTypeSelection (com);
	}
	
	/**
	 * RandomTypeSelection.type can contain any EClass from the input meta-model.
	 */
	def IScope scope_RandomTypeSelection_type(RandomTypeSelection com, EReference ref) {
		System.out.println("4.")
		anyTypeSelection (com);
	}

	/**
	 * OtherTypeSelection.type can contain any EClass from the input meta-model.
	 */
	def IScope scope_OtherTypeSelection_type(OtherTypeSelection com, EReference ref) {
		System.out.println("4b.")
		anyTypeSelection (com);
	}
	
	/**
	 * Common implementation for methods scope_CompleteTypeSelection_type, scope_RandomTypeSelection_type and scope_OtherTypeSelection_type.
	 */
	private def IScope anyTypeSelection(ObSelectionStrategy com) {
		val MutatorEnvironment env = getMutatorEnvironment(com)
        val Definition definition  = env.definition
        val scope = new ArrayList()
		
		if (com.eContainer instanceof ModifyTargetReferenceMutator) {
  			val ModifyTargetReferenceMutator mutator = com.eContainer as ModifyTargetReferenceMutator
  			if (mutator.source == com) { // estamos modificando el source
        		scope.addAll(getESources(definition.metamodel, mutator.refType.name))
  			} 
  			else if (mutator.newTarget == com) { // estamos modificando el newTarget
        		scope.addAll(getETargets(definition.metamodel, mutator.refType.name))
  			} 
		}
		else if (com.eContainer instanceof CreateReferenceMutator) {
  			val CreateReferenceMutator mutator = com.eContainer as CreateReferenceMutator
  			if (mutator.source == com) { // estamos modificando el source
        		scope.addAll(getESources(definition.metamodel, mutator.refType.name))
  			} 
  			else if (mutator.target == com) { // estamos modificando el newTarget
        		scope.addAll(getETargets(definition.metamodel, mutator.refType.name))
  			} 
		}
		else if (com.eContainer instanceof MutatorEnvironment ||
			     com.eContainer instanceof CreateObjectMutator ||
			     com.eContainer instanceof SelectObjectMutator) {
       		// add metamodel classes to scope
        	scope.addAll(getEClasses(definition.metamodel))
		}       

   		Scopes.scopeFor(scope) 
	}	

	/**
	 * SpecificObjectSelection.objSel can contain any EClass from the input meta-model.
	 */
	def IScope scope_SpecificObjectSelection_objSel(SpecificObjectSelection com, EReference ref) {
		System.out.println("5.")		
   		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        val List<Mutator> scope = new ArrayList<Mutator>()
        
		if (com.eContainer instanceof ModifyTargetReferenceMutator) {
  			val ModifyTargetReferenceMutator mutator = com.eContainer as ModifyTargetReferenceMutator
  			val List<Mutator> commands = getCommands(mutator)
  			
  			if (mutator.source == com) { // estamos modificando el source
  				val List<EClass> containers  = getESources(definition.metamodel, mutator.refType.name)
        		val List<String> scontainers = new ArrayList<String>() 
        		for (EClassifier cl : containers) scontainers.add(cl.name)

        		for (c : commands) {
        			if (c.name != null && 
        				commands.indexOf(c) < commands.indexOf(mutator) &&
        				(c instanceof CreateObjectMutator || c instanceof SelectObjectMutator) && 
        				scontainers.contains(c.type.name)){ 
						scope.add(c)
					}
				}
        
       			// add objects to scope
        		Scopes.scopeFor(scope)        	
        	}         
  		
  			else if (mutator.newTarget == com) { // estamos modificando el newTarget
  				val List<EClass> containments  = getETargets(definition.metamodel, mutator.refType.name)
        		val List<String> scontainments = new ArrayList<String>() 
        		for (EClassifier cl : containments) scontainments.add(cl.name)

        		for (c : commands) {
        			if (c.name != null && 
        				commands.indexOf(c) < commands.indexOf(mutator) &&
        				(c instanceof CreateObjectMutator || c instanceof SelectObjectMutator) && 
        				scontainments.contains(c.type.name)){ 
						scope.add(c)
					}
				}
        
       			// add objects to scope
        		Scopes.scopeFor(scope) 
  			}  		
  		} 
  		else if (com.eContainer instanceof CreateReferenceMutator) {
  			val CreateReferenceMutator mutator = com.eContainer as CreateReferenceMutator
  			val List<Mutator> commands = getCommands(mutator)
  			
  			if (mutator.source == com) { // estamos modificando el source
  				val List<EClass> containers  = getESources(definition.metamodel, mutator.refType.name)
        		val List<String> scontainers = new ArrayList<String>() 
        		for (EClassifier cl : containers) scontainers.add(cl.name)

        		for (c : commands) {
        			if (c.name != null && 
        				commands.indexOf(c) < commands.indexOf(mutator) &&
        				(c instanceof CreateObjectMutator || c instanceof SelectObjectMutator) && 
        				scontainers.contains(c.type.name)){ 
						scope.add(c)
					}
				}
        
       			// add objects to scope
        		Scopes.scopeFor(scope)        	
        	}         
  		
  			else if (mutator.target == com) { // estamos modificando el newTarget
  				val List<EClass> containments  = getETargets(definition.metamodel, mutator.refType.name)
        		val List<String> scontainments = new ArrayList<String>() 
        		for (EClassifier cl : containments) scontainments.add(cl.name)

        		for (c : commands) {
        			if (c.name != null && 
        				commands.indexOf(c) < commands.indexOf(mutator) &&
        				(c instanceof CreateObjectMutator || c instanceof SelectObjectMutator) && 
        				scontainments.contains(c.type.name)){ 
						scope.add(c)
					}
				}
        
       			// add objects to scope
        		Scopes.scopeFor(scope) 
  			}  		
  		}		 
	}
					
	/**
	 * CreateObjectMutator.container, when a random type is used as a container, 
	 * can contain any EClass which is a container for the created object.
	 */
	def IScope scope_RandomTypeSelection_type(CreateObjectMutator com, EReference ref) {
		System.out.println("6.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        Scopes.scopeFor( getEContainers(definition.metamodel, com.type.name) )              
	}
	
	/**
	 * SelectObjectMutator.container, when a random type is used as a container, 
	 * can contain any EClass which is a container for the created object.
	 */
	def IScope scope_RandomTypeSelection_type(SelectObjectMutator com, EReference ref) {
		System.out.println("6b.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        Scopes.scopeFor( getEContainers(definition.metamodel, com.type.name) )              
	}
	
	/**
	 * CreateObjetMutator.refType can contain any EReference defined by the 
	 * CreateObjectMutator.container whose type is CreateObjetMutator.type.
	 */
	def IScope scope_CreateObjectMutator_refType(CreateObjectMutator com, EReference ref) {
		System.out.println("7.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        
        // the only possibility is that the container is a RandomTypeSelection
        if (com.container instanceof RandomTypeSelection) {
        	val EClass container = (com.container as RandomTypeSelection).type
        	
        	// add references to scope
        	Scopes.scopeFor( getEContainmentReferences(definition.metamodel, container.name, com.type.name) )              
        }
    }
	
	
	/**
	 * CreateObjetMutator.refType can contain any EReference defined by the 
	 * CreateObjectMutator.container whose type is CreateObjetMutator.type.
	 */
	def IScope scope_SelectObjectMutator_refType(SelectObjectMutator com, EReference ref) {
		System.out.println("7b.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        
        // the only possibility is that the container is a RandomTypeSelection
        if (com.container instanceof RandomTypeSelection) {
        	val EClass container = (com.container as RandomTypeSelection).type
        	
        	// add references to scope
        	Scopes.scopeFor( getEContainmentReferences(definition.metamodel, container.name, com.type.name) )              
        }
    }
    
	/**
	 * ModifySourceReferenceMutator.refType can contain any EReference in the metamodel.
	 */
	def IScope scope_ModifySourceReferenceMutator_refType(ModifySourceReferenceMutator com, EReference ref) {
		System.out.println("8.")
		System.out.println("AQUI 1.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        
        Scopes.scopeFor( getEReferences(definition.metamodel) )              
    }
    
    /**
	 * ModifyTargetReferenceMutator.refType can contain any EReference in the metamodel.
	 */
	def IScope scope_ModifyTargetReferenceMutator_refType(ModifyTargetReferenceMutator com, EReference ref) {
		System.out.println("9.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        
       	// add references to scope
       	Scopes.scopeFor( getEReferences(definition.metamodel) )              
    }
    
    /**
	 * CreateReferenceMutator.refType can contain any EReference in the metamodel.
	 */
	def IScope scope_CreateReferenceMutator_refType(CreateReferenceMutator com, EReference ref) {
		System.out.println("10.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        
       	// add references to scope
       	Scopes.scopeFor( getEReferences(definition.metamodel) )              
    }
    
	/**
	 * ModifySourceReferenceMutator.from and ModifySourceReferenceMutator.newSource, when a specific 
	 * object is used as from/to, can contain any previous object defining the modified reference. 
	 */
	def IScope scope_SpecificObjectSelection_objSel(ModifySourceReferenceMutator com, EReference ref) {				
		System.out.println("11.")
		System.out.println("AQUI 2.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
        val List<Mutator> commands = getCommands(com)
        val Definition definition  = env.definition
        val scope = new ArrayList()
        
        val List<EClass> containers  = getESources(definition.metamodel, com.refType.name)
        val List<String> scontainers = new ArrayList<String>() 
        for (EClassifier cl : containers) scontainers.add(cl.name)

        for (mutator : commands) {
        	if (mutator.name != null && 
        		commands.indexOf(mutator) < commands.indexOf(com) &&
        		(mutator instanceof CreateObjectMutator || mutator instanceof SelectObjectMutator) && 
        		scontainers.contains(mutator.type.name)) 
				scope.add(mutator) // add object to scope
		}
        
        Scopes.scopeFor(scope)
	}
	
	/**
	 * ModifySourceReferenceMutator.from and ModifySourceReferenceMutator.to, when a random 
	 * type is used as from/to, can contain any EClass which defines the modified reference.
	 */
	def IScope scope_RandomTypeSelection_type(ModifySourceReferenceMutator com, EReference ref) {
		System.out.println("12.")
		System.out.println("AQUI 3.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        
        Scopes.scopeFor( getESources(definition.metamodel, com.refType.name) )              
	}
	
	def private ArrayList<EClass> HelperRandomTypeSelectionModelEClasses(Definition definition, Program program) {
		val scope = new ArrayList()
		/*if (program.source.multiple == false) {*/
		if (!program.source.path.endsWith('/')) {
        	scope.addAll(getModelEClasses(definition.metamodel, program.source.path))
        }
        if (program.source.path.endsWith('/')) {
		/*if (program.source.multiple == true) {*/
        	val File[] files = new File(program.source.path).listFiles()
        	for (file : files) {
				if (file.isFile() == true) {
					if (file.getPath().endsWith(".model") == true) {
						scope.addAll(getModelEClasses(definition.metamodel, file.getPath))
					}
				}
			}
			return scope
		}
	}
	
	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RandomTypeSelection_type(RemoveObjectMutator com, EReference ref) {
		System.out.println("13.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	val Program program = definition as Program
        	val scope = HelperRandomTypeSelectionModelEClasses(definition, program)
        	Scopes.scopeFor(scope)    
        }
	}
	
	/**
	 * RemoveObjectMutator.object, when a specific selection strategy is used.
	 */
	def IScope scope_SpecificObjectSelection_objSel(RemoveObjectMutator com, EReference ref) {
		System.out.println("14.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
		val List<Mutator> commands = getCommands(com)
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	Scopes.scopeFor( commands )
        }          
	}
	
	/**
	 * RemoveObjectMutator.object, when a complete type is used.
	 */
	def IScope scope_CompleteTypeSelection_type(RemoveObjectMutator com, EReference ref) {
		System.out.println("15.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	val Program program = definition as Program
        	val scope = HelperRandomTypeSelectionModelEClasses(definition, program)
        	Scopes.scopeFor(scope)    
        }
	}
	

	/**
	 * ModifyInformationMutator.object, when a specific 
	 * object is used, can contain any previous object defining the modified reference. 
	 */
	def IScope scope_ObjectEmitter_type(SpecificObjectSelection com, EReference ref) {
		System.out.println("16.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	Scopes.scopeFor( getEClasses(definition.metamodel) )    
        }
	}

	/**
	 * ModifyInformationMutator.object, when a specific 
	 * object is used, can contain any previous object defining the modified reference. 
	 */
	def IScope scope_SpecificObjectSelection_objSel(ModifyInformationMutator com, EReference ref) {
		System.out.println("17.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
        val List<Mutator> commands = getCommands(com)
        val Definition definition  = env.definition
        
        if(definition instanceof Program) {
        	val scope = new ArrayList()
        	if (!definition.source.path.endsWith('/')) {
			/*if (definition.source.multiple == false) {*/
        		val String model = definition.source.path
        		val List<EClass> classes  = getModelEClasses(definition.metamodel, model)
        		val List<String> sclasses = new ArrayList<String>() 
       			for (EClassifier cl : classes) sclasses.add(cl.name) {
       				val List<Mutator> objects = new ArrayList<Mutator>()
		        	for (mutator : commands) {
    	    		if (mutator.name != null && 
        				commands.indexOf(mutator) < commands.indexOf(com) &&
        				(mutator instanceof CreateObjectMutator || mutator instanceof SelectObjectMutator) && 
        				sclasses.contains(mutator.type.name)) 
						objects.add(mutator)
					}
		        	scope.addAll(objects)
				}
			}
			if (definition.source.path.endsWith('/')) {
			/*if (definition.source.multiple == true) {*/
				val ArrayList<String> models = new ArrayList<String>()
				val File[] files = new File(definition.source.path).listFiles()
        		for (file : files) {
					if (file.isFile() == true) {
						if (file.getPath().endsWith(".model") == true) {
							models.add(file.getPath())
						}
					}
				}
				val List<EClass> classes = new ArrayList<EClass>()
				for (model : models) {
        			classes.addAll(getModelEClasses(definition.metamodel, model))
        		}
        		val List<String> sclasses = new ArrayList<String>() 
       			for (EClassifier cl : classes) sclasses.add(cl.name) {
       				val List<Mutator> objects = new ArrayList<Mutator>()
		        	for (mutator : commands) {
    	    		if (mutator.name != null && 
        				commands.indexOf(mutator) < commands.indexOf(com) &&
        				(mutator instanceof CreateObjectMutator || mutator instanceof SelectObjectMutator) && 
        				sclasses.contains(mutator.type.name)) 
						objects.add(mutator)
					}
		        	scope.addAll(objects)
				}
			}
        	// add objects to scope
        	Scopes.scopeFor(scope)
        }       
	}

	/**
	 * ModifyInformationMutator.object, when a random type is used.
	 */
	def IScope scope_RandomTypeSelection_type(ModifyInformationMutator com, EReference ref) {
		System.out.println("18.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if (definition instanceof Program) {
	      	Scopes.scopeFor( getEClasses(definition.metamodel) )    
        }          
	}
	
	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RemoveRandomReferenceMutator_refType(RemoveRandomReferenceMutator com, EReference ref) {
		System.out.println("19.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	Scopes.scopeFor( getEReferences(definition.metamodel) )    
        }          
	}
	
	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RemoveRandomReferenceMutator_type(RemoveRandomReferenceMutator com, EReference ref) {
		System.out.println("20.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	Scopes.scopeFor( getEClasses(definition.metamodel) )    
        }          
	}
	
	def private ArrayList<EClass> HelperRandomTypeSelectionModelESources(Definition definition, Program program, String refTypeName) {
		val scope = new ArrayList()
		if (!program.source.path.endsWith('/')) {
		/*if (program.source.multiple == false) {*/
        	scope.addAll(getModelEClasses(definition.metamodel, program.source.path))
        }
        if (program.source.path.endsWith('/')) {
		/*if (program.source.multiple == true) { */
        	val File[] files = new File(program.source.path).listFiles()
        	for (file : files) {
				if (file.isFile() == true) {
					if (file.getPath().endsWith(".model") == true) {
						scope.addAll(getModelESources(definition.metamodel, file.getPath, refTypeName))
					}
				}
			}
			return scope
		}
	}
	
	/**
	 * RemoveReferenceMutator.container, when a random 
	 * type is used, can contain any EClass which defines the modified reference.
	 */
	def IScope scope_RandomTypeSelection_type(RemoveRandomReferenceMutator com, EReference ref) {
		System.out.println("21.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	val Program program = definition as Program
        	val scope = HelperRandomTypeSelectionModelESources(definition, program, com.refType.name)
        	Scopes.scopeFor(scope)    
        }
	}
	
	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RemoveCompleteReferenceMutator_refType(RemoveCompleteReferenceMutator com, EReference ref) {
		System.out.println("22.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	val scope = new ArrayList()
        	scope.addAll(getEReferences(definition.metamodel))
        	Scopes.scopeFor(scope)    
        }          
	}
	
	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RemoveCompleteReferenceMutator_type(RemoveCompleteReferenceMutator com, EReference ref) {
		System.out.println("23.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	Scopes.scopeFor( getEClasses(definition.metamodel) )    
        }          
	}
	
	/**
	 * RemoveReferenceMutator.container, when a random 
	 * type is used, can contain any EClass which defines the modified reference.
	 */
	def IScope scope_RandomTypeSelection_type(RemoveCompleteReferenceMutator com, EReference ref) {
		System.out.println("24.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	val Program program = definition as Program
        	val scope = HelperRandomTypeSelectionModelESources(definition, program, com.refType.name)
        	Scopes.scopeFor(scope)    
        }
	}

	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RemoveSpecificReferenceMutator_refType(RemoveSpecificReferenceMutator com, EReference ref) {
		System.out.println("25.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	Scopes.scopeFor( getEReferences(definition.metamodel) )    
        }          
	}
	
	/**
	 * RemoveObjectMutator.object, when a random type is used.
	 */
	def IScope scope_RemoveSpecificReferenceMutator_container(RemoveSpecificReferenceMutator com, EReference ref) {
		System.out.println("26.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
        if(definition instanceof Program) {
        	//val String model = (definition as Program).model
        	Scopes.scopeFor( getEClasses(definition.metamodel) )    
        }          
	}
	/**
	 * RemoveReferenceMutator.container, when a specific 
	 * object is used, can contain any previous object defining the modified reference. 
	 */
	def IScope scope_SpecificObjectSelection_objSel(RemoveSpecificReferenceMutator com, EReference ref) {				
		System.out.println("27.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
        val List<Mutator> commands = getCommands(com)
        val Definition definition  = env.definition
        
        if(definition instanceof Program) {
        	val scope = new ArrayList()
        	if (!definition.source.path.endsWith('/')) {
			/*if (definition.source.multiple == false) {*/
        		val String model = definition.source.path
	        	val List<EClass> containers  = getModelESources(definition.metamodel, model, com.refType.name)
	        	val List<String> scontainers = new ArrayList<String>() 
    	   		for (EClassifier cl : containers) scontainers.add(cl.name)
		       	val List<Mutator> objects = new ArrayList<Mutator>()
        		for (mutator : commands) {
        			if (mutator.name != null && 
        				commands.indexOf(mutator) < commands.indexOf(com) &&
        				(mutator instanceof CreateObjectMutator || mutator instanceof SelectObjectMutator) && 
        				scontainers.contains(mutator.type.name)) 
						objects.add(mutator)
				}
	        	scope.addAll(objects)
    	    }
    	    if (definition.source.path.endsWith('/')) {
			/*if (definition.source.multiple == true) {*/
				val ArrayList<String> models = new ArrayList<String>()
				val File[] files = new File(definition.source.path).listFiles()
        		for (file : files) {
					if (file.isFile() == true) {
						if (file.getPath().endsWith(".model") == true) {
							models.add(file.getPath())
						}
					}
				}
	        	val List<EClass> containers = new ArrayList<EClass>()
				for (model : models) {
        			containers.addAll(getModelESources(definition.metamodel, model, com.refType.name))
        		}
        		val List<String> scontainers = new ArrayList<String>() 
       			for (EClassifier cl : containers) scontainers.add(cl.name)
       			val List<Mutator> objects = new ArrayList<Mutator>()
        		for (mutator : commands) {
        			if (mutator.name != null && 
        				commands.indexOf(mutator) < commands.indexOf(com) &&
        				(mutator instanceof CreateObjectMutator || mutator instanceof SelectObjectMutator) && 
        				scontainers.contains(mutator.type.name)) 
						objects.add(mutator)
				}
	        	scope.addAll(objects)
			}
        	Scopes.scopeFor(scope)
        }       
	}
	
    /**
     * CreateObjectMutator.attributes must contain attributes of the CreateObjetMutator.type type. 
     */
    def IScope scope_AttributeSet_attribute(CreateObjectMutator com, EReference ref) {
		System.out.println("28.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
       	Scopes.scopeFor( getEAttributes(definition.metamodel, com.type.name) )              
    }
    
    /**
     * CreateObjectMutator.attributes must contain attributes of the CreateObjetMutator.type type. 
     */  
    def IScope scope_ReferenceSet_reference(CreateObjectMutator com, EReference ref) {
		System.out.println("28b.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
        val Definition  definition = env.definition
       	Scopes.scopeFor( getEReferences(definition.metamodel, com.type.name) )              
    }
    
    /**
     * ModifyInformationMutator.attributes must contain attributes of the ModifyInformationMutator.object type. 
     */
    def IScope scope_AttributeSet_attribute(ModifyInformationMutator com, EReference ref) {
		System.out.println("29.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		val List<Mutator> commands = getCommands(com)
        val Definition  definition = env.definition
       	val scope = new ArrayList()
       	if(com.object instanceof SpecificObjectSelection) {
       		val String name = (com.object as SpecificObjectSelection).objSel.name
			var command = getCommand (name, commands, commands.indexOf(com))
			if (command!=null) scope.addAll( getEAttributes(definition?.metamodel, getType(command)) )
       	}
        else if(com.object instanceof CompleteTypeSelection){
       		val String name = (com.object as CompleteTypeSelection).type.name
       		for (EAttribute eatt: getEAttributes(definition.metamodel, name)) {
       			System.out.println("attribute: "+ eatt.name)
       		}
			scope.addAll(getEAttributes(definition.metamodel, name))
       	}
       	else if(com.object instanceof RandomTypeSelection){
       		val String name = (com.object as RandomTypeSelection).type.name
       		for (EAttribute eatt: getEAttributes(definition.metamodel, name)) {
       			System.out.println("attribute: "+ eatt.name)
       		}
			scope.addAll(getEAttributes(definition.metamodel, name))
       	}
       	Scopes.scopeFor(scope)              
    }

    /**
     * ModifyInformationMutator.attributes must contain attributes of the ModifyInformationMutator.object type. 
     */
    def IScope scope_ReferenceSet_reference(ModifyInformationMutator com, EReference ref) {
		System.out.println("29b.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		val List<Mutator> commands = getCommands(com)
        val Definition  definition = env.definition
       	val scope = new ArrayList()
       	if(com.object instanceof SpecificObjectSelection) {
       		val String name = (com.object as SpecificObjectSelection).objSel.name
			var command = getCommand (name, commands, commands.indexOf(com))
			if (command!=null) scope.addAll( getEReferences(definition?.metamodel, getType(command)) )
       	}
        else if(com.object instanceof CompleteTypeSelection){
       		val String name = (com.object as CompleteTypeSelection).type.name
       		for (EReference eref: getEReferences(definition.metamodel, name)) {
       			System.out.println("reference: "+ eref.name)
       		}
			scope.addAll(getEReferences(definition.metamodel, name))
       	}
       	else if(com.object instanceof RandomTypeSelection){
       		val String name = (com.object as RandomTypeSelection).type.name
       		for (EReference eref: getEReferences(definition.metamodel, name)) {
       			System.out.println("reference: "+ eref.name)
       		}
			scope.addAll(getEReferences(definition.metamodel, name))
       	}
       	Scopes.scopeFor(scope)       
    }

    /**
     * ReferenceInit.refType must contain references of the type of ReferenceInit.object. 
     */
    def IScope scope_ReferenceSet_refType (ReferenceInit com, EReference container) {
    	System.out.println("30a.")    	
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		if (env!=null) {
			val Definition  definition = env.definition
			
			// obtain mutator that contains the specific object selection
			val Mutator currentMutator = EcoreUtil2.getContainerOfType(com, Mutator)
			val List<Mutator> commands = getCommands(currentMutator)
			var String      objectName = com.object?.type?.name
			if (com.object instanceof SpecificObjectSelection) 
				objectName = (com.object as SpecificObjectSelection)?.objSel?.name
			
			// search specific selected object among the previous commands
			var command = getCommand (objectName, commands, commands.indexOf(currentMutator))
			if (command!=null) return Scopes.scopeFor( getEReferences(definition?.metamodel, getType(command)) )			
       	}
       	Scopes.scopeFor(new ArrayList())
    }
    
    // TODO: similar for ReferenceSwap.reference, but in this case, the object is optional, in which case, we take the type of the closest object in the mutation
    /**
     * ReferenceSwap.reference must contain references of the type of ReferenceSwap.object,
     * or of the type of the mutator if no object is specified. 
     */
    def IScope scope_ReferenceSet_reference (ReferenceSwap com, EReference container) {
    	System.out.println("30b.")    	
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		if (env!=null) {
			val Definition  definition = env.definition
			
			// obtain mutator that contains the specific object selection
			val Mutator currentMutator = EcoreUtil2.getContainerOfType(com, Mutator)
			val List<Mutator> commands = getCommands(currentMutator)
			if (com.object == null) return Scopes.scopeFor( getEReferences(definition?.metamodel, getType(currentMutator)) )
			
			var String      objectName = com.object?.type?.name
			if (com.object instanceof SpecificObjectSelection) 
				objectName = (com.object as SpecificObjectSelection)?.objSel?.name
				
			// search specific selected object among the previous commands
			var command = getCommand (objectName, commands, commands.indexOf(currentMutator))
			if (command!=null) return Scopes.scopeFor( getEReferences(definition?.metamodel, getType(command)) )
       	}
       	Scopes.scopeFor(new ArrayList())
    }

  	/**
     * ReferenceEvaluation.name must contain the references defined by com.type 
     */
     def IScope scope_ReferenceEvaluation_name(RandomTypeSelection com, EReference ref) {
    	System.out.println("31a.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
		if (env!=null) {
        	val Definition  definition = env.definition
   			val String       className = com.type?.name
       		Scopes.scopeFor( getEReferences(definition?.metamodel, className) )
       	}
       	else Scopes.scopeFor(new ArrayList())
    }
    
  	/**
     * ReferenceEvaluation.name must contain the references defined by com.type 
     */
     def IScope scope_ReferenceEvaluation_name(CompleteTypeSelection com, EReference ref) {
    	System.out.println("31b.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
		if (env!=null) {
        	val Definition  definition = env.definition
   			val String       className = com.type?.name
       		Scopes.scopeFor( getEReferences(definition?.metamodel, className) )
       	}
       	else Scopes.scopeFor(new ArrayList())
    }
    
  	/**
     * ReferenceEvaluation.name must contain the references defined by ... 
     */
     def IScope scope_ReferenceEvaluation_name(SpecificObjectSelection com, EReference ref) {
    	System.out.println("31c.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		if (env!=null) {
			val Definition  definition = env.definition
			
			// obtain mutator that contains the specific object selection
			val Mutator currentMutator = EcoreUtil2.getContainerOfType(com, Mutator)
			val List<Mutator> commands = getCommands(currentMutator)
			val String      objectName = com.objSel?.name
			
			// search specific selected object among the previous commands
			var command = getCommand (objectName, commands, commands.indexOf(currentMutator))
			if (command!=null) return Scopes.scopeFor( getEReferences(definition?.metamodel, getType(command)) )
       	}
       	Scopes.scopeFor(new ArrayList())
    }    
    
  	/**
     * AttributeEvaluation.name must contain the attributes defined by com.type 
     */
    def IScope scope_AttributeEvaluation_name(RandomTypeSelection com, EReference ref) {
    	System.out.println("32a.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
		if (env!=null) {
        	val Definition  definition = env.definition
   			val String       className = com.type?.name
       		Scopes.scopeFor( getEAttributes(definition?.metamodel, className) )
       	}
       	else Scopes.scopeFor(new ArrayList())
    }
    
  	/**
     * AttributeEvaluation.name must contain the attributes defined by com.type 
     */
     def IScope scope_AttributeEvaluation_name(CompleteTypeSelection com, EReference ref) {
    	System.out.println("32b.")
		val MutatorEnvironment env = getMutatorEnvironment(com)
		if (env!=null) {
        	val Definition  definition = env.definition
   			val String       className = com.type?.name
       		Scopes.scopeFor( getEAttributes(definition?.metamodel, className) )
       	}
       	else Scopes.scopeFor(new ArrayList())
    }    

  	/**
     * AttributeEvaluation.name must contain the attributes defined by ...
     */
     def IScope scope_AttributeEvaluation_name(SpecificObjectSelection com, EReference ref) {
    	System.out.println("32c.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		if (env!=null) {
			val Definition  definition = env.definition
			
			// obtain mutator that contains the specific object selection
			val Mutator currentMutator = EcoreUtil2.getContainerOfType(com, Mutator)
			val List<Mutator> commands = getCommands(currentMutator)
			val String      objectName = com.objSel?.name
			
			// search specific selected object among the previous commands
			var command = getCommand (objectName, commands, commands.indexOf(currentMutator))
			if (command!=null) return Scopes.scopeFor( getEAttributes(definition?.metamodel, getType(command)) )
       	}
       	Scopes.scopeFor(new ArrayList())
    }

  	/**
     * ModifyInformationMutator.attributes must contain attributes of the ModifyInformationMutator.object type. 
     */
    def IScope scope_ReferenceEvaluation_refType(SelectObjectMutator com, EReference ref) {
		System.out.println("33.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		val List<Mutator> commands = getCommands(com)
        val Definition  definition = env.definition
        var String name = ""
       	val scope = new ArrayList()
       	if(com.object instanceof SpecificObjectSelection) {
       		name = (com.object as SpecificObjectSelection).objSel.name
			var command = getCommand (name, commands, commands.indexOf(com))
			if (command!=null) scope.addAll( getEReferences(definition?.metamodel, getType(command)) )			
       	}
        else if(com.object instanceof CompleteTypeSelection){
       		name = (com.object as CompleteTypeSelection).type.name
       		for (EReference eref: getEReferences(definition.metamodel, name)) {
       			System.out.println("reference: "+ eref.name)
       		}
			scope.addAll(getEReferences(definition.metamodel, name))
       	}
       	else if(com.object instanceof RandomTypeSelection){
       		name = (com.object as RandomTypeSelection).type.name
       		for (EReference eref: getEReferences(definition.metamodel, name)) {
       			System.out.println("reference: "+ eref.name)
       		}
			scope.addAll(getEReferences(definition.metamodel, name))
       	}
       	Scopes.scopeFor(scope)              
    }
    
    /**
     * ModifyInformationMutator.attributes must contain attributes of the ModifyInformationMutator.object type. 
     */
    def IScope scope_ReferenceEvaluation_refType(ModifyInformationMutator com, EReference ref) {
		System.out.println("33b.")
		val MutatorEnvironment env = getMutatorEnvironment(com) 
		val List<Mutator> commands = getCommands(com)
        val Definition  definition = env.definition
       	val scope = new ArrayList()
       	if(com.object instanceof SpecificObjectSelection) {
       		val String name = (com.object as SpecificObjectSelection).objSel.name
			var command = getCommand (name, commands, commands.indexOf(com))
			if (command!=null) scope.addAll( getEReferences(definition?.metamodel, getType(command)) )
       	}
        else if(com.object instanceof CompleteTypeSelection){
       		val String name = (com.object as CompleteTypeSelection).type.name
       		for (EReference eref: getEReferences(definition.metamodel, name)) {
       			System.out.println("reference: "+ eref.name)
       		}
			scope.addAll(getEReferences(definition.metamodel, name))
       	}
       	else if(com.object instanceof RandomTypeSelection){
       		val String name = (com.object as RandomTypeSelection).type.name
       		for (EReference eref: getEReferences(definition.metamodel, name)) {
       			System.out.println("reference: "+ eref.name)
       		}
			scope.addAll(getEReferences(definition.metamodel, name))
       	}
       	Scopes.scopeFor(scope)              
    }

    /**
     * ModifyInformationMutator.attributes must contain attributes of the ModifyInformationMutator.object type. 
     */
    def IScope scope_ReferenceEvaluation_refType(RandomTypeSelection com, EReference ref) {
		System.out.println("33c.")
   		val scope = new ArrayList()
      	
      	var EObject mut = null
       	if ( com.eContainer instanceof ReferenceInit &&
       		(com.eContainer.eContainer instanceof CreateObjectMutator ||
       		 com.eContainer.eContainer instanceof SelectObjectMutator)) {
    	   		mut = com.eContainer.eContainer
		}
       	else if (com.eContainer instanceof CreateObjectMutator ||
       		com.eContainer instanceof SelectObjectMutator || 
       		com.eContainer instanceof ModifyInformationMutator) {
       		mut = com.eContainer
       	}
       	
       	if (mut != null) {
			val MutatorEnvironment env = getMutatorEnvironment(com) 
        	val Definition  definition = env.definition
       		val List<Mutator> commands = getCommands(mut as Mutator)
		    if (com.expression != null) {
	        	val Expression exp = com.expression
	        	if (exp.first instanceof ReferenceEvaluation) {
		        	val ReferenceEvaluation first = exp.first as ReferenceEvaluation
		        	if (first.value != null) {
		        		if (first.value instanceof SpecificObjectSelection) {
		    				if ((first.value as SpecificObjectSelection).objSel != null) {
			       				val String name = (first.value as SpecificObjectSelection).objSel.name
			       				System.out.println("name: " + name);
	       						var command = getCommand (name, commands, commands.indexOf(mut))
	       						if (command!=null) scope.addAll( getEReferences(definition?.metamodel, getType(command)) )
		        			}
		        		}
		        	}
		        	for (Evaluation second : exp.second) {
		        		if (second instanceof ReferenceEvaluation) {
		        			if (second.value instanceof SpecificObjectSelection) {
		        				if ((second.value as SpecificObjectSelection).objSel != null) {
				       				val String name = (second.value as SpecificObjectSelection).objSel.name
       								var command = getCommand (name, commands, commands.indexOf(mut))
       								if (command!=null) scope.addAll( getEReferences(definition?.metamodel, getType(command)) )
		        				}
		        			}
	        			}
	        		}
	        	}
		    }
       	}
       	
       	Scopes.scopeFor(scope)             
    }
    
    /**
	 * Constraint.type can contain any EClass from the input meta-model.
	 */
	def IScope scope_Constraint_type(Constraint c, EReference ref) {
		System.out.println("34.")
		val MutatorEnvironment env = getMutatorEnvironment(c)
        val Definition  definition = env.definition
       	// add metamodel classes to scope
       	Scopes.scopeFor( getEClasses(definition.metamodel) )   
	}				
    
 	//--------------------------------------------------------------------------------------
	// PRIVATE METHODS
	//--------------------------------------------------------------------------------------
	
	/**
	 * It returns the mutator environment that contains an object
	 */
	 def private MutatorEnvironment getMutatorEnvironment (ObjectEmitter oe) { EcoreUtil2.getContainerOfType(oe, MutatorEnvironment) }
	 def private MutatorEnvironment getMutatorEnvironment (ReferenceSet  oe) { EcoreUtil2.getContainerOfType(oe, MutatorEnvironment) }
	 def private MutatorEnvironment getMutatorEnvironment (Constraint oe) { EcoreUtil2.getContainerOfType(oe, MutatorEnvironment) }
	 
	/**
	 * It returns the list of commands in the scope of the received mutator. 
	 * The scope can be either the environment or a composite mutator.
	 * @param Mutator
	 * @return List<Mutator>
	 */
	def private List<Mutator> getCommands (Mutator com) {
		if (com.eContainer instanceof Block) return (com.eContainer as Block).commands
		if (com.eContainer instanceof CompositeMutator)   return (com.eContainer as CompositeMutator).commands
		if (com.eContainer instanceof MutatorEnvironment) return (com.eContainer as MutatorEnvironment).commands
		return new ArrayList<Mutator>()
	}
	
    /**
     * It returns the type to which a mutator applies.  
     */
    def private String getType (Mutator mutator) {
    	if (mutator instanceof SelectObjectMutator)      return (mutator as SelectObjectMutator).object?.type?.name
		if (mutator instanceof ModifyInformationMutator) return (mutator as ModifyInformationMutator).object?.type?.name
    	return mutator.type?.name
    }
    
    /**
     * It receives a list of commands, and returns the command with the given name in commands[0..maxindex]. 
     */
     def private Mutator getCommand (String name, List<Mutator> commands, int maxindex) {
     	var Mutator command = null;
     	for (Mutator mutator : commands) {
     		if (mutator.name?.equals(name) && commands.indexOf(mutator) < maxindex) { 
				command = mutator
			}
		}
		return command;
    }

	/** 
	 * It returns the list of classes defined in a meta-model.
	 * @param String file containing the metamodel
	 * @return List<EClass>
	 */
	 def private List<EClass> getEClasses (String metamodelFile) {
        val List<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile)
        val List<EClass>   classes   = new ArrayList<EClass>()
        for (EPackage pck : metamodel)
          for (EClassifier cl : pck.EClassifiers)
            if (cl instanceof EClass)
              classes.add(cl as EClass)
        return classes
	 }
	 
	 /** 
	 * It returns the list of classes existing in a model.
	 * @param String file containing the model
	 * @return List<EClass>
	 */
	 def private List<EClass> getModelEClasses (String metamodelFile, String modelFile) {
        val ArrayList<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile)
        val Resource model = ModelManager.loadModel(metamodel, modelFile)
        val List<EObject>   classes = ModelManager.getAllObjects(model)
        val List<EClass>   ret   = new ArrayList<EClass>()
        for(EObject o : classes){
        	if(!ret.contains(o.eClass())) ret.add(o.eClass())
        }
        return ret
	 }
	 
	/** 
	 * It returns the list of references defined in a meta-model.
	 * @param String file containing the metamodel
	 * @return List<EReference>
	 */
	 def private List<EReference> getEReferences (String metamodelFile) {
        val List<EPackage>   metamodel  = ModelManager.loadMetaModel(metamodelFile)
        val List<EReference> references = new ArrayList<EReference>()
        for (EPackage pck : metamodel)
          for (EClassifier cl : pck.EClassifiers)
            if (cl instanceof EClass)
              references.addAll((cl as EClass).EReferences)
        return references
	 }
	 
	 /**
	  * It returns the list of classes which can contain (through a containment relation) the given class.
	  * @param String file containing the metamodel
	  * @param String class name
	  * @return List<EClass> list of containers
	  */
	  def private List<EClass> getEContainers (String metamodelFile, String eclassName) {
	  	// get all container eclassifiers
	  	val List<EPackage>    metamodel  = ModelManager.loadMetaModel(metamodelFile)
        val List<EClassifier> containers = ModelManager.getContainerTypes(metamodel, eclassName)
        
        // filter to keep only eclasses
        val List<EClass> classes = new ArrayList<EClass>()
        for (EClassifier cl : containers)
          if (cl instanceof EClass)
            classes.add(cl as EClass)
        return classes    
	  } 
	  
	 /**
	  * It returns the list of classes which defines the given relation.
	  * @param String file containing the metamodel
	  * @param String class name
	  * @return List<EClass> list of containers
	  */
	  def private List<EClass> getESources (String metamodelFile, String ereferenceName) {
	  	val List<EClass> eclasses = getEClasses(metamodelFile)
	  	// filter to keep only eclasses which define the received reference
	  	val List<EClass> esources = new ArrayList<EClass>()
	  	for (EClass cl : eclasses) {
	    	System.out.println("class: " + cl.getName())
	  	  	if (cl.getEStructuralFeature(ereferenceName)!=null)
	  	    	esources.add(cl)
	  	    }
	  	return esources    
	  }
	  
	  
	  /**
	  * It returns the list of classes which are pointed by the given relation.
	  * @param String file containing the metamodel
	  * @param String class name
	  * @return List<EClass> list of containments
	  */
	  def private List<EClass> getETargets (String metamodelFile, String ereferenceName) {
	  	val List<EClass> eclasses = getEClasses(metamodelFile)
	  	val List<EReference> ereferences = getEReferences(metamodelFile)
	  	
	  	// MODIFICAR ESTE METODO
	  	// filter to keep only eclasses contained by the received reference
	  	val List<EClass> etargets = new ArrayList<EClass>()
	  	for (EClass cl : eclasses){
	  		for(EReference rl : ereferences){
	  			if(cl.getName().equals(rl.getEType.getName()) && rl.getName().equals(ereferenceName)){
	  				etargets.add(cl)	  				
	  			}
	  		}
	  	}
	  	return etargets    
	  }
	  
	  /**
	  * It returns the list of classes which defines the given relation.
	  * @param String file containing the metamodel
	  * @param String class name
	  * @return List<EClass> list of containers
	  */
	  def private List<EClass> getModelESources (String metamodelFile, String modelFile, String ereferenceName) {
	  	val List<EClass> eclasses = getModelEClasses(metamodelFile, modelFile)
	  	
	  	// filter to keep only eclasses which define the received reference
	  	val List<EClass> esources = new ArrayList<EClass>()
	  	for (EClass cl : eclasses)
	  	  if (cl.getEStructuralFeature(ereferenceName)!=null)
	  	    esources.add(cl)
	  	return esources    
	  } 	  

	 /**
	  * It returns the list of containment references from a source class to a target class.
	  * @param String file containing the metamodel
	  * @param String source class name
	  * @param String target class name
	  * @return List<EReference> list of references
	  */
	  def private List<EReference> getEContainmentReferences (String metamodelFile, String esourceclassName, String etargetclassName) {
	  	val List<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile)
	  	val EClass sourceclass = ModelManager.getObjectOfType(esourceclassName, metamodel) as EClass 
	  	val EClass targetclass = ModelManager.getObjectOfType(etargetclassName, metamodel) as EClass

	  	val List<EReference> references = new ArrayList<EReference>()
	  	for (EReference ref : sourceclass.EAllReferences) {
	  		if (ref.EReferenceType.isSuperTypeOf(targetclass) && // the same target type, or a supertype 
	  			ref.containment && ref.changeable) // containment
	  		    references.add(ref)	  		
	  	}
	  	
	  	return references 
	  }
	  
	  /**
	   * It return the list of attributes of a class.
	   * @param String file containing the metamodel
	   * @param String class name
	   * @return List<EAttribute> list of attributes
	   */ 
	   def private List<EAttribute> getEAttributes (String metamodelFile, String eclassName) {
	   	System.out.println("def private List<EAttribute> getEAttributes (String metamodelFile=" + metamodelFile + ", String eclassName=" + eclassName + ")")
	  	val List<EPackage>    metamodel  = ModelManager.loadMetaModel(metamodelFile)
	  	val EClass            eclass     = ModelManager.getObjectOfType(eclassName, metamodel) as EClass
	  	if (eclass!=null) {
	  		return eclass.EAllAttributes
		}
	  	else {
	  		return new ArrayList<EAttribute>()
	  	}
  	}
  	
	  /**
	   * It return the list of attributes of a class.
	   * @param String file containing the metamodel
	   * @param String class name
	   * @return List<EAttribute> list of attributes
	   */ 
	   def private List<EReference> getEReferences (String metamodelFile, String eclassName) {
	   	System.out.println("def private List<EAttribute> getEAttributes (String metamodelFile=" + metamodelFile + ", String eclassName=" + eclassName + ")")
	  	val List<EPackage>    metamodel  = ModelManager.loadMetaModel(metamodelFile)
	  	val EClass            eclass     = ModelManager.getObjectOfType(eclassName, metamodel) as EClass
	  	if (eclass!=null) {
	  		return eclass.EAllReferences
		}
	  	else {
	  		return new ArrayList<EReference>()
	  	}
  	}
}