/**
 * generated by Xtext
 */
package wodeledu.dsls.scoping;

import com.google.common.base.Objects;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import manager.ModelManager;
import mutatext.Configuration;
import mutatext.Option;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.Platform;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.osgi.framework.Bundle;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MutaTextScopeProvider extends AbstractDeclarativeScopeProvider {
  /**
   * Option.type can refer to any EClass in the .ecore file.
   */
  public IScope scope_Option_type(final Option opt, final EReference ref) {
    String _metamodelFilename = this.getMetamodelFilename();
    List<EClass> _eClasses = this.getEClasses(_metamodelFilename);
    return Scopes.scopeFor(_eClasses);
  }
  
  /**
   * Option.object is an optional argument that can be any EClass in the metamodel.
   */
  public IScope scope_Option_object(final Option option, final EReference ref) {
    EObject _eContainer = option.eContainer();
    String _metamodel = ((Configuration) _eContainer).getMetamodel();
    List<EClass> _eClasses = this.getEClasses(_metamodel);
    return Scopes.scopeFor(_eClasses);
  }
  
  /**
   * It returns the list of classes defined in a meta-model.
   * @param String file containing the metamodel
   * @return List<EClass>
   */
  private List<EClass> getEClasses(final String metamodelFile) {
    try {
      final List<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile);
      final List<EClass> classes = new ArrayList<EClass>();
      for (final EPackage pck : metamodel) {
        EList<EClassifier> _eClassifiers = pck.getEClassifiers();
        for (final EClassifier cl : _eClassifiers) {
          if ((cl instanceof EClass)) {
            classes.add(((EClass) cl));
          }
        }
      }
      return classes;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * It return the list of attributes of a class.
   * @param String file containing the metamodel
   * @param String class name
   * @return List<EAttribute> list of attributes
   */
  private List<EAttribute> getEAttributes(final String metamodelFile, final String eclassName) {
    try {
      System.out.println((((("def private List<EAttribute> getEAttributes (String metamodelFile=" + metamodelFile) + ", String eclassName=") + eclassName) + ")"));
      final ArrayList<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile);
      final Resource model = ModelManager.loadModel(metamodel, metamodelFile);
      EObject _objectOfType = ModelManager.getObjectOfType(eclassName, metamodel);
      final EClass eclass = ((EClass) _objectOfType);
      final List<EObject> containers = ModelManager.getContainerObjects(model, eclassName);
      ArrayList<EAttribute> atts = new ArrayList<EAttribute>();
      boolean _notEquals = (!Objects.equal(eclass, null));
      if (_notEquals) {
        EList<EAttribute> _eAllAttributes = eclass.getEAllAttributes();
        atts.addAll(_eAllAttributes);
        boolean _notEquals_1 = (!Objects.equal(containers, null));
        if (_notEquals_1) {
          for (final EObject cont : containers) {
            EList<EAttribute> _eAllAttributes_1 = ((EClass) cont).getEAllAttributes();
            atts.addAll(_eAllAttributes_1);
          }
        }
      }
      return atts;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * It returns the list of references of a class.
   * @param String file containing the metamodel
   * @param String class name
   * @return List<EReference>
   */
  private List<EReference> getEReferences(final String metamodelFile, final String eclassName) {
    try {
      final ArrayList<EPackage> metamodel = ModelManager.loadMetaModel(metamodelFile);
      final Resource model = ModelManager.loadModel(metamodel, metamodelFile);
      EObject _objectOfType = ModelManager.getObjectOfType(eclassName, metamodel);
      final EClass eclass = ((EClass) _objectOfType);
      final List<EObject> containers = ModelManager.getContainerObjects(model, eclassName);
      ArrayList<EReference> refs = new ArrayList<EReference>();
      boolean _notEquals = (!Objects.equal(eclass, null));
      if (_notEquals) {
        EList<EReference> _eAllReferences = eclass.getEAllReferences();
        refs.addAll(_eAllReferences);
        boolean _notEquals_1 = (!Objects.equal(containers, null));
        if (_notEquals_1) {
          for (final EObject cont : containers) {
            EList<EReference> _eAllReferences_1 = ((EClass) cont).getEAllReferences();
            refs.addAll(_eAllReferences_1);
          }
        }
      }
      return refs;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * It returns the metamodel filename for the Applied Mutations
   */
  private String getMetamodelFilename() {
    try {
      final Bundle bundle = Platform.getBundle("wodel.models");
      final URL fileURL = bundle.getEntry("/models/AppliedMutations.ecore");
      URL _resolve = FileLocator.resolve(fileURL);
      return _resolve.getFile();
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
