/**
 * generated by Xtext
 */
package wodel.dsls.validation;

import com.google.common.base.Objects;
import exceptions.MetaModelNotFoundException;
import java.io.File;
import java.util.ArrayList;
import manager.ModelManager;
import mutatorenvironment.AttributeCopy;
import mutatorenvironment.AttributeReverse;
import mutatorenvironment.AttributeScalar;
import mutatorenvironment.AttributeSet;
import mutatorenvironment.AttributeSwap;
import mutatorenvironment.AttributeType;
import mutatorenvironment.AttributeUnset;
import mutatorenvironment.BooleanType;
import mutatorenvironment.CreateObjectMutator;
import mutatorenvironment.DoubleType;
import mutatorenvironment.IntegerType;
import mutatorenvironment.ListStringType;
import mutatorenvironment.ModifyInformationMutator;
import mutatorenvironment.Mutator;
import mutatorenvironment.Program;
import mutatorenvironment.Source;
import mutatorenvironment.StringType;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import wodel.dsls.validation.AbstractWodelValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class WodelValidator extends AbstractWodelValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String INVALID_METAMODEL = "invalidMetamodel";
  
  public final static String INVALID_MODEL = "invalidModel";
  
  public final static String INVALID_UNSET = "invalidUnset";
  
  public final static String INVALID_SWAP = "invalidSwap";
  
  public final static String INVALID_COPY = "invalidCopy";
  
  public final static String INVALID_TYPE = "invalidType";
  
  public final static String WARNING_MODIFY_SOURCE = "warningModifySource";
  
  public final static String INVALID_EXPRESSION = "invalidExpression";
  
  public final static String INVALID_REVERSE = "invalidReverse";
  
  private ArrayList<EPackage> packages;
  
  private String lastMetamodel = "";
  
  @Check
  public void checkProgramModel(final Program p) {
    Source _source = p.getSource();
    String _path = _source.getPath();
    boolean _endsWith = _path.endsWith("/");
    boolean _not = (!_endsWith);
    if (_not) {
      Source _source_1 = p.getSource();
      String _path_1 = _source_1.getPath();
      boolean _checkModel = ModelManager.checkModel(_path_1);
      boolean _not_1 = (!_checkModel);
      if (_not_1) {
        Source _source_2 = p.getSource();
        String _path_2 = _source_2.getPath();
        String _plus = ("Cannot find model" + _path_2);
        this.error(_plus, null, WodelValidator.INVALID_MODEL);
      }
    }
    Source _source_3 = p.getSource();
    String _path_3 = _source_3.getPath();
    boolean _endsWith_1 = _path_3.endsWith("/");
    if (_endsWith_1) {
      Source _source_4 = p.getSource();
      String _path_4 = _source_4.getPath();
      File _file = new File(_path_4);
      final File[] files = _file.listFiles();
      for (final File file : files) {
        boolean _isFile = file.isFile();
        boolean _equals = (_isFile == true);
        if (_equals) {
          String _path_5 = file.getPath();
          boolean _endsWith_2 = _path_5.endsWith(".model");
          boolean _equals_1 = (_endsWith_2 == true);
          if (_equals_1) {
            String _path_6 = file.getPath();
            boolean _checkModel_1 = ModelManager.checkModel(_path_6);
            boolean _not_2 = (!_checkModel_1);
            if (_not_2) {
              String _path_7 = file.getPath();
              String _plus_1 = ("Cannot find model " + _path_7);
              this.error(_plus_1, null, WodelValidator.INVALID_MODEL);
            }
          }
        }
      }
    }
  }
  
  @Check
  public ArrayList<EPackage> checkProgramMetaModel(final Program p) {
    ArrayList<EPackage> _xblockexpression = null;
    {
      String path = p.getMetamodel();
      ArrayList<EPackage> _xtrycatchfinallyexpression = null;
      try {
        ArrayList<EPackage> _xifexpression = null;
        boolean _equals = this.lastMetamodel.equals(path);
        boolean _not = (!_equals);
        if (_not) {
          ArrayList<EPackage> _xblockexpression_1 = null;
          {
            this.lastMetamodel = path;
            ArrayList<EPackage> _loadMetaModel = ModelManager.loadMetaModel(path);
            _xblockexpression_1 = this.packages = _loadMetaModel;
          }
          _xifexpression = _xblockexpression_1;
        }
        _xtrycatchfinallyexpression = _xifexpression;
      } catch (final Throwable _t) {
        if (_t instanceof MetaModelNotFoundException) {
          final MetaModelNotFoundException e = (MetaModelNotFoundException)_t;
          String _string = e.toString();
          this.error(_string, null, WodelValidator.INVALID_METAMODEL);
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xblockexpression = _xtrycatchfinallyexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkCreateObjectMutatorMin(final CreateObjectMutator com) {
    int _min = ((Mutator) com).getMin();
    int _max = ((Mutator) com).getMax();
    boolean _greaterThan = (_min > _max);
    if (_greaterThan) {
      this.error("The min value must me lower or equal than the max value.", null, WodelValidator.INVALID_NAME);
    }
    EList<AttributeSet> attributes = com.getAttributes();
    for (final AttributeSet attset : attributes) {
      {
        if ((attset instanceof AttributeUnset)) {
          EList<EAttribute> _attribute = ((AttributeUnset)attset).getAttribute();
          EAttribute att = _attribute.get(0);
          boolean _and = false;
          boolean _isUnsettable = att.isUnsettable();
          boolean _equals = (_isUnsettable == false);
          if (!_equals) {
            _and = false;
          } else {
            int _lowerBound = att.getLowerBound();
            boolean _notEquals = (_lowerBound != 0);
            _and = _notEquals;
          }
          if (_and) {
            this.error("The attribute is not unsettable and the lower bound is not 0", null, WodelValidator.INVALID_UNSET);
          }
          boolean _isUnsettable_1 = att.isUnsettable();
          boolean _equals_1 = (_isUnsettable_1 == false);
          if (_equals_1) {
            this.error("The attribute is not unsettable", null, WodelValidator.INVALID_UNSET);
          }
          int _lowerBound_1 = att.getLowerBound();
          boolean _notEquals_1 = (_lowerBound_1 != 0);
          if (_notEquals_1) {
            this.error("The lower bound is not 0", null, WodelValidator.INVALID_UNSET);
          }
        }
        if ((attset instanceof AttributeSwap)) {
          System.out.println(("SWAP: attset: " + attset));
          EList<EAttribute> _attribute_1 = ((AttributeSwap)attset).getAttribute();
          EAttribute att0 = _attribute_1.get(0);
          EList<EAttribute> _attribute_2 = ((AttributeSwap)attset).getAttribute();
          EAttribute att1 = _attribute_2.get(1);
          EClassifier _eType = att0.getEType();
          Class<?> _instanceClass = _eType.getInstanceClass();
          EClassifier _eType_1 = att1.getEType();
          Class<?> _instanceClass_1 = _eType_1.getInstanceClass();
          boolean _notEquals_2 = (!Objects.equal(_instanceClass, _instanceClass_1));
          if (_notEquals_2) {
            this.error("The attributes are not of the same type", null, WodelValidator.INVALID_SWAP);
          }
        }
        if ((attset instanceof AttributeCopy)) {
          System.out.println(("COPY: attset: " + attset));
          EList<EAttribute> _attribute_3 = ((AttributeCopy)attset).getAttribute();
          EAttribute att0_1 = _attribute_3.get(0);
          EList<EAttribute> _attribute_4 = ((AttributeCopy)attset).getAttribute();
          EAttribute att1_1 = _attribute_4.get(1);
          EClassifier _eType_2 = att0_1.getEType();
          Class<?> _instanceClass_2 = _eType_2.getInstanceClass();
          EClassifier _eType_3 = att1_1.getEType();
          Class<?> _instanceClass_3 = _eType_3.getInstanceClass();
          boolean _notEquals_3 = (!Objects.equal(_instanceClass_2, _instanceClass_3));
          if (_notEquals_3) {
            this.error("The attributes are not of the same type", null, WodelValidator.INVALID_COPY);
          }
        }
        if ((attset instanceof AttributeScalar)) {
          EList<EAttribute> _attribute_5 = ((AttributeScalar)attset).getAttribute();
          EAttribute att0_2 = _attribute_5.get(0);
          AttributeType att_type = ((AttributeScalar)attset).getValue();
          if ((att_type instanceof IntegerType)) {
            EClassifier _eType_4 = att0_2.getEType();
            String _instanceClassName = _eType_4.getInstanceClassName();
            boolean _equals_2 = _instanceClassName.equals("int");
            boolean _not = (!_equals_2);
            if (_not) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof BooleanType)) {
            EClassifier _eType_5 = att0_2.getEType();
            String _instanceClassName_1 = _eType_5.getInstanceClassName();
            boolean _equals_3 = _instanceClassName_1.equals("boolean");
            boolean _not_1 = (!_equals_3);
            if (_not_1) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof StringType)) {
            EClassifier _eType_6 = att0_2.getEType();
            String _instanceClassName_2 = _eType_6.getInstanceClassName();
            boolean _equals_4 = _instanceClassName_2.equals("java.lang.String");
            boolean _not_2 = (!_equals_4);
            if (_not_2) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof DoubleType)) {
            EClassifier _eType_7 = att0_2.getEType();
            String _instanceClassName_3 = _eType_7.getInstanceClassName();
            String _plus = ("DoubleType: " + _instanceClassName_3);
            System.out.println(_plus);
            EClassifier _eType_8 = att0_2.getEType();
            String _instanceClassName_4 = _eType_8.getInstanceClassName();
            boolean _equals_5 = _instanceClassName_4.equals("double");
            boolean _not_3 = (!_equals_5);
            if (_not_3) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof ListStringType)) {
            EClassifier _eType_9 = att0_2.getEType();
            String _instanceClassName_5 = _eType_9.getInstanceClassName();
            boolean _equals_6 = _instanceClassName_5.equals("java.lang.String");
            boolean _not_4 = (!_equals_6);
            if (_not_4) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkModifyInformationMutatorUnset(final ModifyInformationMutator com) {
    EList<AttributeSet> attributes = com.getAttributes();
    for (final AttributeSet attset : attributes) {
      {
        if ((attset instanceof AttributeUnset)) {
          EList<EAttribute> _attribute = ((AttributeUnset)attset).getAttribute();
          EAttribute att = _attribute.get(0);
          boolean _and = false;
          boolean _isUnsettable = att.isUnsettable();
          boolean _equals = (_isUnsettable == false);
          if (!_equals) {
            _and = false;
          } else {
            int _lowerBound = att.getLowerBound();
            boolean _notEquals = (_lowerBound != 0);
            _and = _notEquals;
          }
          if (_and) {
            this.error("The attribute is not unsettable and the lower bound is not 0", null, WodelValidator.INVALID_UNSET);
          }
          boolean _isUnsettable_1 = att.isUnsettable();
          boolean _equals_1 = (_isUnsettable_1 == false);
          if (_equals_1) {
            this.error("The attribute is not unsettable", null, WodelValidator.INVALID_UNSET);
          }
          int _lowerBound_1 = att.getLowerBound();
          boolean _notEquals_1 = (_lowerBound_1 != 0);
          if (_notEquals_1) {
            this.error("The lower bound is not 0", null, WodelValidator.INVALID_UNSET);
          }
        }
        if ((attset instanceof AttributeSwap)) {
          System.out.println(("SWAP: attset: " + attset));
          EList<EAttribute> _attribute_1 = ((AttributeSwap)attset).getAttribute();
          EAttribute att0 = _attribute_1.get(0);
          EList<EAttribute> _attribute_2 = ((AttributeSwap)attset).getAttribute();
          EAttribute att1 = _attribute_2.get(1);
          EClassifier _eType = att0.getEType();
          Class<?> _instanceClass = _eType.getInstanceClass();
          EClassifier _eType_1 = att1.getEType();
          Class<?> _instanceClass_1 = _eType_1.getInstanceClass();
          boolean _notEquals_2 = (!Objects.equal(_instanceClass, _instanceClass_1));
          if (_notEquals_2) {
            this.error("The attributes are not of the same type", null, WodelValidator.INVALID_SWAP);
          }
        }
        if ((attset instanceof AttributeCopy)) {
          System.out.println(("COPY: attset: " + attset));
          EList<EAttribute> _attribute_3 = ((AttributeCopy)attset).getAttribute();
          EAttribute att0_1 = _attribute_3.get(0);
          EList<EAttribute> _attribute_4 = ((AttributeCopy)attset).getAttribute();
          EAttribute att1_1 = _attribute_4.get(1);
          EClassifier _eType_2 = att0_1.getEType();
          Class<?> _instanceClass_2 = _eType_2.getInstanceClass();
          EClassifier _eType_3 = att1_1.getEType();
          Class<?> _instanceClass_3 = _eType_3.getInstanceClass();
          boolean _notEquals_3 = (!Objects.equal(_instanceClass_2, _instanceClass_3));
          if (_notEquals_3) {
            this.error("The attributes are not of the same type", null, WodelValidator.INVALID_COPY);
          }
        }
        if ((attset instanceof AttributeScalar)) {
          EList<EAttribute> _attribute_5 = ((AttributeScalar)attset).getAttribute();
          EAttribute att0_2 = _attribute_5.get(0);
          AttributeType att_type = ((AttributeScalar)attset).getValue();
          if ((att_type instanceof IntegerType)) {
            EClassifier _eType_4 = att0_2.getEType();
            String _instanceClassName = _eType_4.getInstanceClassName();
            boolean _equals_2 = _instanceClassName.equals("int");
            boolean _not = (!_equals_2);
            if (_not) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof BooleanType)) {
            EClassifier _eType_5 = att0_2.getEType();
            String _instanceClassName_1 = _eType_5.getInstanceClassName();
            boolean _equals_3 = _instanceClassName_1.equals("boolean");
            boolean _not_1 = (!_equals_3);
            if (_not_1) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof StringType)) {
            EClassifier _eType_6 = att0_2.getEType();
            String _instanceClassName_2 = _eType_6.getInstanceClassName();
            boolean _equals_4 = _instanceClassName_2.equals("java.lang.String");
            boolean _not_2 = (!_equals_4);
            if (_not_2) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof DoubleType)) {
            EClassifier _eType_7 = att0_2.getEType();
            String _instanceClassName_3 = _eType_7.getInstanceClassName();
            String _plus = ("DoubleType: " + _instanceClassName_3);
            System.out.println(_plus);
            EClassifier _eType_8 = att0_2.getEType();
            String _instanceClassName_4 = _eType_8.getInstanceClassName();
            boolean _equals_5 = _instanceClassName_4.equals("double");
            boolean _not_3 = (!_equals_5);
            if (_not_3) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
          if ((att_type instanceof ListStringType)) {
            EClassifier _eType_9 = att0_2.getEType();
            String _instanceClassName_5 = _eType_9.getInstanceClassName();
            boolean _equals_6 = _instanceClassName_5.equals("java.lang.String");
            boolean _not_4 = (!_equals_6);
            if (_not_4) {
              this.error("The attributes are not of the same type", null, WodelValidator.INVALID_TYPE);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkAttributeSet(final AttributeSet attset) {
    if ((attset instanceof AttributeReverse)) {
      EList<EAttribute> _attribute = ((AttributeReverse)attset).getAttribute();
      EAttribute _get = _attribute.get(0);
      EClassifier _eType = _get.getEType();
      String _instanceClassName = _eType.getInstanceClassName();
      boolean _equals = _instanceClassName.equals("boolean");
      boolean _not = (!_equals);
      if (_not) {
        EList<EAttribute> _attribute_1 = ((AttributeReverse)attset).getAttribute();
        EAttribute _get_1 = _attribute_1.get(0);
        EClassifier _eType_1 = _get_1.getEType();
        String _instanceClassName_1 = _eType_1.getInstanceClassName();
        String _plus = ("The reverse operator is only valid for boolean arguments, not for " + _instanceClassName_1);
        this.error(_plus, null, WodelValidator.INVALID_REVERSE);
      }
    }
  }
}
